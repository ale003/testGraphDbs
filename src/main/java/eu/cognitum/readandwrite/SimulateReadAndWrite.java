// ============================================================================================================== 
// Â© 2014 Cognitum. All rights reserved.  
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance  
// with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 
// Unless required by applicable law or agreed to in writing, software distributed under the License is  
// distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  
// See the License for the specific language governing permissions and limitations under the License. 
// ============================================================================================================== 
package eu.cognitum.readandwrite;

import java.io.FileNotFoundException;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.fusesource.jansi.internal.Kernel32;
import org.openrdf.repository.Repository;
import org.openrdf.repository.RepositoryException;

/**
 * Thread used to execute the generation of the RDF graph, writing it on the db
 * and reading using sparql.
 *
 * @author Alessandro Seganti (Data Engineer @Cognitum)
 * @version 0.0
 * @since 2014-04-10
 * @copyright Cognitum, Poland 2014
 */
public class SimulateReadAndWrite extends Thread {

    private RdfReadHandler _rdfReadHandler;
    private RdfGenerator _rdfGenerator;
    public Repository rep;
    public String fileName;

    public long lastCommitTime;
    public int Nstatements;
    public String outputName;
    public String graphDbUsed;
    public String keyspace;
    public String currentNamespace = "http://www.ontorion.com/testontology.owl#";
    private int _commitBufferSize;

    private int _NelementsFinal;
    private int _step;
    private Thread _thread;
    private boolean _stopped = false;
    private boolean _finished = false;
    private boolean _started = false;
    private boolean _error = false;
    private int _NelementsCurrent = 0;

    /**
     * Class to simulate both read and write for a generic repository.
     *
     * @param repExt RDF repository to use
     * @param Nelements Number of elements to be generated by the simulation.
     * @param readStep Number of element to load in the repository before each
     * read.
     * @param commitBufferSize Number of element to load before commiting the
     * changes to the Repository.
     */
    public SimulateReadAndWrite(Repository repExt, String outputNameExt, int Nelements, int readStep, int commitBufferSize, String graphDbUsedExt, String keyspaceExt, String currentNameSpace, boolean skipReading) throws RepositoryException, FileNotFoundException {

        outputName = outputNameExt;
        fileName = outputNameExt+".rdf";
        rep = repExt;
        _commitBufferSize = commitBufferSize;
        _NelementsFinal = Nelements;
        _step = readStep;
        graphDbUsed = graphDbUsedExt;
        keyspace = keyspaceExt;

        _rdfGenerator = new GenerateRdf(currentNamespace, fileName);
        _rdfReadHandler = new RdfReadHandler(this, _rdfGenerator, this.currentNamespace);
    }

    public int GetReadStep() {
        return _step;
    }

    public int GetCommitBufferSize() {
        return _commitBufferSize;
    }

    /**
     * same work of startProcess but asyncronously
     */
    public void run() {
        if (_started) {
            return;
        }

        _finished = _stopped = _error = false;

        try {
            Logger.getLogger(SimulateReadAndWrite.class.getName()).log(Level.INFO,graphDbUsed+": Generating the rdf....");
            _rdfGenerator.generateAndSaveRdf(_NelementsFinal);
            Logger.getLogger(SimulateReadAndWrite.class.getName()).log(Level.INFO,graphDbUsed+": Generated an rdf with "+_NelementsFinal+" elements"+_rdfGenerator.getNtriples()+" triples. Starting to read and writing it.");
           _rdfReadHandler.readAll(fileName);
        } catch (Exception ex) {
            _error = true;
            Logger.getLogger(SimulateReadAndWrite.class.getName()).log(Level.SEVERE, "########################## AN ERROR OCCURED IN THE THREAD!\n");
            Logger.getLogger(SimulateReadAndWrite.class.getName()).log(Level.SEVERE, null,ex);
        } finally {
            _finished = true;
            _started = false;
        }
        _started = true;
    }

    /**
     * stop the current process. It will before wait for the process to finish
     * one iteration and then stop it.
     */
    public void StopProcess() {
        _stopped = true;
    }

    /**
     * return true if the process started has been completed
     */
    public boolean IsProcessCompleted() {
        return _finished;
    }

    /**
     * Give the process status
     */
    public String GetProcessStatus() {
        boolean processCompleted = IsProcessCompleted();

        if (_error == true) {
            return "Error";
        } else if (_stopped == true && processCompleted) {
            return "Stopped by the user";
        } else if (_stopped == true && !processCompleted) {
            return "Stopping";
        } else if (!processCompleted) {
            return "Working";
        } else {
            return "Completed";
        }

    }

    /**
     * give the percentage of process completed
     */
    public double GetProgress() {
        return (double) (100 * ((double) _rdfReadHandler.NtriplesCompleted / (double) _rdfGenerator.getNtriples()));
    }

}
